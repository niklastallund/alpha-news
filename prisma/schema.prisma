/**
 * NEWS PROJECT — DATAMODELL (förklaring)
 *
 * Syfte:
 * Denna datamodell är utformad för en komplett nyhetsplattform som hanterar användarautentisering, innehållsproduktion och publicering, prenumerationer, betalningar, kommunikation, personalisering, integrationer, analys samt dataskydd. Modellen möjliggör skalbarhet, hög dataintegritet och tydlig separation mellan olika domäner.
 *
 * Domäner och modeller:
 * - AUTH: User, Role, UserRole, Session, EmailVerificationToken, PasswordResetToken
 * - CONTENT: Category, Tag, MediaAsset, Article, ArticleVersion, ArticleTag, Comment, Reaction, CommentReport, EditorPickOrder
 * - COMMERCE: SubscriptionType, Subscription, PaymentMethod, PaymentIntent, Invoice, Product, Order, OrderItem
 * - COMMS: Newsletter, NewsletterSubscription, NewsletterSchedule, OutboxJob, EmailQueue
 * - PERSONALIZATION: Bookmark, ReadHistory
 * - INTEGRATIONS: ExternalDataCache, WebhookEvent
 * - OPS/ANALYTICS: PageView, AuditLog
 * - PRIVACY: ConsentEvent
 *
 * Viktiga relationer:
 * - User → Article (författarskap)
 * - User → Subscription (prenumerationer)
 * - User → Comment, Reaction, Bookmark, ReadHistory (interaktion och personalisering)
 * - Article → Category, Article → Tag (klassificering)
 * - Article → ArticleVersion (versionshistorik)
 * - Article → Comment, Reaction, Bookmark, ReadHistory (användarinteraktion)
 * - Article → EditorPickOrder (utvald artikel)
 * - Subscription → PaymentIntent, Invoice (betalningsflöde)
 * - User → NewsletterSubscription → Newsletter (nyhetsbrev)
 * - User → PaymentMethod, PaymentIntent, Order (handel)
 * - Product → OrderItem → Order (webshop)
 * - User → ConsentEvent (samtyckeshistorik)
 * - User → PageView, AuditLog (analys och loggning)
 *
 * Index och constraints:
 * - Unika index på email, sluggar, kombinationer av id:n (t.ex. [userId, roleId], [slug, language]), och andra naturliga nycklar för att säkerställa dataintegritet och snabba uppslag.
 * - Constraints såsom @unique, @id, och sammansatta index för att förhindra dubbletter och säkerställa korrekt relationshantering.
 * - Många relationer använder onDelete: Cascade/SetNull för att hantera borttagning på ett säkert sätt.
 * - CHECK constraints (t.ex. på Article, Subscription, Invoice) hanteras i SQL-migreringar för avancerad datavalidering.
 *
 * Modellens uppbyggnad:
 * - Separation av domäner möjliggör modulär utveckling och enkel utbyggnad.
 * - Relationsmodellen stödjer både många-till-många (ArticleTag, UserRole) och en-till-många/valfri (t.ex. UserProfile).
 * - Indexering och constraints är utformade för att möjliggöra hög prestanda vid sökningar och rapportering.
 *
 * Praktiskt flöde:
 * - Användare kan registrera sig, logga in, hantera sin profil och preferenser.
 * - Redaktionella användare kan skapa, redigera och publicera artiklar med versionering och klassificering.
 * - Prenumeranter kan köpa prenumerationer, hantera betalningar och ta emot fakturor.
 * - Nyhetsbrev skickas till prenumeranter enligt schema och köhantering.
 * - Användare kan interagera med innehåll via reaktioner, kommentarer, bokmärken och läsa historik, vilket möjliggör personalisering.
 * - Systemet lagrar samtycken, hanterar integrationer (t.ex. väderdata), och loggar viktiga händelser för analys och regelefterlevnad.
 */
// ---------------------------
// Prisma Client + Datakälla
// ---------------------------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------
// ENUMS
// ---------------------------

enum RoleName {
  ADMIN
  EDITOR
  READER
}

enum ArticleStatus {
  DRAFT
  REVIEW
  SCHEDULED
  PUBLISHED
  ARCHIVED
}

enum ReactionKind {
  LIKE
  LOVE
  INSIGHTFUL
  SAD
  ANGRY
}

enum NewsletterCadence {
  DAILY
  WEEKLY
  CUSTOM
}

enum PaymentStatus {
  REQUIRES_ACTION
  SUCCEEDED
  FAILED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum RenewalMode {
  NONE
  MANUAL
  AUTO
}

// ---------------------------
// AUTH / USERS
// ---------------------------
// Bas: användare, roller, sessioner och e-postflöden

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  passwordHash    String
  status          String           @default("ACTIVE")
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations
  roles           UserRole[]
  sessions        Session[]
  emailTokens     EmailVerificationToken[]
  passwordResets  PasswordResetToken[]

  // Content & interaktion
  articles        Article[]        @relation("AuthorArticles")
  comments        Comment[]
  reactions       Reaction[]
  bookmarks       Bookmark[]
  readHistory     ReadHistory[]
  editedVersions  ArticleVersion[] @relation("EditedVersions")
  reportedComments CommentReport[] @relation("UserCommentReports")
  orders          Order[]          @relation("UserOrders")
  pageViews       PageView[]       @relation("UserPageViews")
  consents        ConsentEvent[]   @relation("UserConsents")

  // Betalning & prenumerationer
  subscriptions   Subscription[]
  invoices        Invoice[]
  paymentMethods  PaymentMethod[]
  payments        PaymentIntent[]  @relation("UserPayments")

  // Kommunikation
  newsletterSubs  NewsletterSubscription[]
  emailQueueItems EmailQueue[]     @relation("EmailQueueToUser")

  // Profil & preferenser
  profile         UserProfile?
  preference      UserPreference?

  // Loggar
  auditLogs       AuditLog[]       @relation("ActorAuditLogs")
}

model Role {
  id          String     @id @default(cuid())
  name        RoleName   @unique
  description String?

  users       UserRole[]
}

model UserRole {
  userId String
  roleId String
  user   User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  meta      Json?
}

/// E-postverifiering och reset-tokens
model EmailVerificationToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  consumedAt DateTime?
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  consumedAt DateTime?
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ---------------------------
// USER EXTRAS (publik profil + inställningar)
// ---------------------------

model UserProfile {
  userId      String  @id
  displayName String
  authorSlug  String  @unique   // offentlig URL-slug för författarsida
  avatarUrl   String?
  bio         String?
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([authorSlug])
}

model UserPreference {
  userId            String   @id
  locale            String   @default("sv-SE")
  timezone          String   @default("Europe/Stockholm")
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(false)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ---------------------------
// CONTENT
// ---------------------------
// Kategorier, taggar, media, artikel (med versionshistorik)

model Category {
  id        String    @id @default(cuid())
  slug      String    @unique
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  articles  Article[]

  @@index([deletedAt])
}

model Tag {
  id        String    @id @default(cuid())
  slug      String    @unique
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  articles  ArticleTag[]

  @@index([deletedAt])
}

model MediaAsset {
  id         String   @id @default(cuid())
  kind       String   // "image" | "video" | ...
  url        String
  width      Int?
  height     Int?
  alt        String?
  checksum   String?  @unique
  createdBy  String?
  createdAt  DateTime @default(now())
  deletedAt  DateTime?

  articles  Article[] @relation("ArticleImage")
  products  Product[] @relation("ProductImage")

  @@index([deletedAt])
}

model Article {
  id             String        @id @default(cuid())
  // Slug unik per språk för i18n-stöd
  slug           String
  language       String        @default("sv")
  headline       String
  summary        String?
  contentRich    Json          // editor/blocks som JSON
  imageId        String?
  image          MediaAsset?   @relation("ArticleImage", fields: [imageId], references: [id])
  categoryId     String
  category       Category      @relation(fields: [categoryId], references: [id])
  authorId       String
  author         User          @relation("AuthorArticles", fields: [authorId], references: [id])
  status         ArticleStatus @default(DRAFT)
  isEditorChoice Boolean       @default(false)
  scheduledAt    DateTime?
  publishedAt    DateTime?
  views          Int           @default(0)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  deletedAt      DateTime?

  // Relations
  versions       ArticleVersion[]
  tags           ArticleTag[]
  comments       Comment[]
  reactions      Reaction[]
  bookmarks      Bookmark[]
  reads          ReadHistory[]
  editorPick     EditorPickOrder? @relation("EditorPick")
  pageViews      PageView[]       @relation("ArticlePageViews")

  @@unique([slug, language])
  @@index([status, publishedAt(sort: Desc)])
  @@index([categoryId])
  @@index([authorId])
  @@index([deletedAt])
  @@index([scheduledAt])
  // Publicering får inte vara före planering
  // NOTE: CHECK flyttad till SQL-migration (ALTER TABLE Article ADD CONSTRAINT ...)
}

model ArticleVersion {
  id         String   @id @default(cuid())
  articleId  String
  versionNo  Int
  diff       Json?
  snapshot   Json?    // full snapshot om ni vill
  editorId   String?
  note       String?
  createdAt  DateTime @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  editor     User?    @relation("EditedVersions", fields: [editorId], references: [id])

  @@unique([articleId, versionNo])
}

model ArticleTag {
  articleId String
  tagId     String
  article   Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([articleId, tagId])
}


model Comment {
  id         String   @id @default(cuid())
  articleId  String
  userId     String
  body       String
  status     String   @default("VISIBLE") // VISIBLE|HIDDEN|FLAGGED
  createdAt  DateTime @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports     CommentReport[] @relation("CommentReports")

  @@index([articleId, status])
}

model Reaction {
  id         String       @id @default(cuid())
  articleId  String
  userId     String
  kind       ReactionKind
  createdAt  DateTime     @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([articleId, userId, kind])
}

// Rapporter för moderation
model CommentReport {
  id         String   @id @default(cuid())
  commentId  String
  reporterId String?
  reason     String
  createdAt  DateTime @default(now())
  comment    Comment  @relation("CommentReports", fields: [commentId], references: [id], onDelete: Cascade)
  reporter   User?    @relation("UserCommentReports", fields: [reporterId], references: [id], onDelete: SetNull)
  @@index([commentId, createdAt])
}

// Editor’s choice ordning per period
model EditorPickOrder {
  id        String   @id @default(cuid())
  articleId String   @unique
  rank      Int
  fromDate  DateTime
  toDate    DateTime?

  article   Article  @relation("EditorPick", fields: [articleId], references: [id], onDelete: Cascade)
  @@index([fromDate, toDate])
}

// ---------------------------
// COMMERCE (prenumeration + betalning + fakturor)
// ---------------------------

model SubscriptionType {
  id           String   @id @default(cuid())
  name         String   @unique
  description  String?
  priceSek     Decimal  @db.Decimal(10,2)
  durationDays Int
  features     Json?
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  subscriptions Subscription[]
}

model Subscription {
  id          String              @id @default(cuid())
  userId      String
  typeId      String
  startedAt   DateTime            @default(now())
  expiresAt   DateTime
  status      SubscriptionStatus  @default(ACTIVE)
  renewalMode RenewalMode         @default(NONE)

  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        SubscriptionType    @relation(fields: [typeId], references: [id])
  payments    PaymentIntent[]
  invoices    Invoice[]

  @@index([userId, status])
  // NOTE: CHECK flyttad till SQL-migration (ALTER TABLE Subscription ADD CONSTRAINT ...)
}

// Kundens sparade betalmetoder (Stripe m.m.)
model PaymentMethod {
  id           String   @id @default(cuid())
  userId       String
  provider     String   // "STRIPE"
  customerRef  String   // t.ex. cus_xxx
  methodRef    String   // t.ex. pm_xxx
  isDefault    Boolean  @default(false)
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, methodRef])
  @@index([userId, isDefault])
}

// Betalningsintentioner (kan kopplas till order eller prenumeration)
model PaymentIntent {
  id             String         @id @default(cuid())
  userId         String
  subscriptionId String?
  orderId        String?
  amountSek      Decimal        @db.Decimal(10,2)
  status         PaymentStatus
  provider       String         // "FAKE" | "STRIPE" | ...
  providerRef    String?        @unique
  idempotencyKey String?        @unique
  createdAt      DateTime       @default(now())

  user           User           @relation("UserPayments", fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription?  @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  order          Order?         @relation(fields: [orderId], references: [id], onDelete: SetNull)
}

model Invoice {
  id             String    @id @default(cuid())
  userId         String
  subscriptionId String?
  amountSek      Decimal   @db.Decimal(10,2)
  vatSek         Decimal   @db.Decimal(10,2)
  issuedAt       DateTime  @default(now())
  paidAt         DateTime?
  pdfUrl         String?

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  // NOTE: CHECKs flyttade till SQL-migration (ALTER TABLE Invoice ADD CONSTRAINT amount/vat >= 0)
}

// (Valfri) enkel webshop för framtida behov
model Product {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  priceSek    Decimal  @db.Decimal(10,2)
  imageId     String?
  image       MediaAsset? @relation("ProductImage", fields: [imageId], references: [id])
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  orderItems  OrderItem[] @relation("ProductOrderItems")
}

model Order {
  id         String   @id @default(cuid())
  userId     String?
  totalSek   Decimal  @db.Decimal(10,2)
  status     String   @default("CREATED") // CREATED|PAID|CANCELLED|FULFILLED
  createdAt  DateTime @default(now())
  paidAt     DateTime?

  user       User?    @relation("UserOrders", fields: [userId], references: [id], onDelete: SetNull)
  items      OrderItem[]
  payments   PaymentIntent[]
}

model OrderItem {
  orderId   String
  productId String
  qty       Int     @default(1)
  unitSek   Decimal @db.Decimal(10,2)

  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product @relation("ProductOrderItems", fields: [productId], references: [id], onDelete: Restrict)

  @@id([orderId, productId])
}

// ---------------------------
// COMMS (nyhetsbrev + mailkö)
// ---------------------------

model Newsletter {
  id          String            @id @default(cuid())
  name        String            @unique
  description String?
  cadence     NewsletterCadence
  templateId  String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  subscriptions NewsletterSubscription[]
  schedule      NewsletterSchedule?
}

model NewsletterSubscription {
  id             String     @id @default(cuid())
  userId         String
  newsletterId   String
  preferences    Json?
  createdAt      DateTime   @default(now())
  unsubscribedAt DateTime?

  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  newsletter  Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)

  @@unique([userId, newsletterId])
}

// Körschema per nyhetsbrev (DAILY/WEEKLY/CUSTOM)
model NewsletterSchedule {
  id           String     @id @default(cuid())
  newsletterId String     @unique
  dayOfWeek    Int?       // 0=Sun..6=Sat (för WEEKLY)
  hourOfDay    Int?       // 0..23
  customSpec   String?    // cron-liknande om CUSTOM
  newsletter   Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)
}

// Outbox/Jobbkö för utskick och andra batchjobb
model OutboxJob {
  id         String   @id @default(cuid())
  kind       String   // "NEWSLETTER_SEND" | "REBUILD_SITEMAP" | ...
  payload    Json
  runAfter   DateTime @default(now())
  attempts   Int      @default(0)
  lastError  String?
  lockedAt   DateTime?
  doneAt     DateTime?

  @@index([kind, runAfter])
}

// E-postkö (transaktionella mail)
model EmailQueue {
  id          String    @id @default(cuid())
  toUserId    String
  subject     String
  bodyHtml    String
  templateId  String?
  scheduledAt DateTime?
  sentAt      DateTime?
  status      String     @default("QUEUED")
  error       String?

  toUser      User       @relation("EmailQueueToUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([status, scheduledAt])
  @@unique([toUserId, subject, scheduledAt])
}

// ---------------------------
// PERSONALIZATION
// ---------------------------

model Bookmark {
  userId    String
  articleId String
  createdAt DateTime @default(now())

  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  article   Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@id([userId, articleId])
}

model ReadHistory {
  id        String   @id @default(cuid())
  userId    String
  articleId String
  readAt    DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
}

// ---------------------------
// INTEGRATIONS
// ---------------------------

model ExternalDataCache {
  id        String   @id @default(cuid())
  source    String   // "WEATHER" | "ELECTRICITY" | ...
  cacheKey  String
  payload   Json
  fetchedAt DateTime @default(now())
  ttlSec    Int      @default(900)

  @@unique([source, cacheKey])
}

model WebhookEvent {
  id          String   @id @default(cuid())
  provider    String
  eventType   String
  payload     Json
  receivedAt  DateTime @default(now())
  processedAt DateTime?
  status      String   @default("PENDING")
  @@index([provider, status])
}

// ---------------------------
// OPS & ANALYTICS
// ---------------------------

model PageView {
  id         String   @id @default(cuid())
  userId     String?
  sessionId  String?
  path       String
  articleId  String?
  occurredAt DateTime @default(now())
  uaHash     String?
  country    String?

  user       User?    @relation("UserPageViews", fields: [userId], references: [id], onDelete: SetNull)
  article    Article? @relation("ArticlePageViews", fields: [articleId], references: [id], onDelete: SetNull)

  @@index([occurredAt])
  @@index([articleId])
}

model AuditLog {
  id           String   @id @default(cuid())
  actorUserId  String?
  action       String   // CREATE|UPDATE|DELETE|PUBLISH|LOGIN|...
  entity       String   // ARTICLE|USER|SUBSCRIPTION|...
  entityId     String?
  metadata     Json?
  createdAt    DateTime @default(now())

  actor        User?    @relation("ActorAuditLogs", fields: [actorUserId], references: [id], onDelete: SetNull)
  @@index([entity, createdAt])
}

// ---------------------------
// PRIVACY / COMPLIANCE
// ---------------------------

model ConsentEvent {
  id         String   @id @default(cuid())
  userId     String?
  kind       String   // "COOKIE" | "TERMS" | "PRIVACY"
  version    String
  granted    Boolean
  ipHash     String?
  uaHash     String?
  occurredAt DateTime @default(now())

  user       User?    @relation("UserConsents", fields: [userId], references: [id], onDelete: SetNull)

  @@index([kind, occurredAt])
}

// ---------------------------
// FTS (manuell patch efter migrering)
// ---------------------------
// Lägg tsvector-kolumner och triggers via SQL efter `prisma migrate` om ni vill ha Postgres FTS.
/**
 * NEWS PROJECT — DATAMODELL (förklaring)
 *
 * Syfte:
 * Denna datamodell är utformad för en komplett nyhetsplattform som hanterar användarautentisering, innehållsproduktion och publicering, prenumerationer, betalningar, kommunikation, personalisering, integrationer, analys samt dataskydd. Modellen möjliggör skalbarhet, hög dataintegritet och tydlig separation mellan olika domäner.
 *
 * Domäner och modeller:
 * - AUTH: User, Role, UserRole, Session, EmailVerificationToken, PasswordResetToken
 * - CONTENT: Category, Tag, MediaAsset, Article, ArticleVersion, ArticleTag, Comment, Reaction, CommentReport, EditorPickOrder
 * - COMMERCE: SubscriptionType, Subscription, PaymentMethod, PaymentIntent, Invoice, Product, Order, OrderItem
 * - COMMS: Newsletter, NewsletterSubscription, NewsletterSchedule, OutboxJob, EmailQueue
 * - PERSONALIZATION: Bookmark, ReadHistory
 * - INTEGRATIONS: ExternalDataCache, WebhookEvent
 * - OPS/ANALYTICS: PageView, AuditLog
 * - PRIVACY: ConsentEvent
 *
 * Viktiga relationer:
 * - User → Article (författarskap)
 * - User → Subscription (prenumerationer)
 * - User → Comment, Reaction, Bookmark, ReadHistory (interaktion och personalisering)
 * - Article → Category, Article → Tag (klassificering)
 * - Article → ArticleVersion (versionshistorik)
 * - Article → Comment, Reaction, Bookmark, ReadHistory (användarinteraktion)
 * - Article → EditorPickOrder (utvald artikel)
 * - Subscription → PaymentIntent, Invoice (betalningsflöde)
 * - User → NewsletterSubscription → Newsletter (nyhetsbrev)
 * - User → PaymentMethod, PaymentIntent, Order (handel)
 * - Product → OrderItem → Order (webshop)
 * - User → ConsentEvent (samtyckeshistorik)
 * - User → PageView, AuditLog (analys och loggning)
 *
 * Index och constraints:
 * - Unika index på email, sluggar, kombinationer av id:n (t.ex. [userId, roleId], [slug, language]), och andra naturliga nycklar för att säkerställa dataintegritet och snabba uppslag.
 * - Constraints såsom @unique, @id, och sammansatta index för att förhindra dubbletter och säkerställa korrekt relationshantering.
 * - Många relationer använder onDelete: Cascade/SetNull för att hantera borttagning på ett säkert sätt.
 * - CHECK constraints (t.ex. på Article, Subscription, Invoice) hanteras i SQL-migreringar för avancerad datavalidering.
 *
 * Modellens uppbyggnad:
 * - Separation av domäner möjliggör modulär utveckling och enkel utbyggnad.
 * - Relationsmodellen stödjer både många-till-många (ArticleTag, UserRole) och en-till-många/valfri (t.ex. UserProfile).
 * - Indexering och constraints är utformade för att möjliggöra hög prestanda vid sökningar och rapportering.
 *
 * Praktiskt flöde:
 * - Användare kan registrera sig, logga in, hantera sin profil och preferenser.
 * - Redaktionella användare kan skapa, redigera och publicera artiklar med versionering och klassificering.
 * - Prenumeranter kan köpa prenumerationer, hantera betalningar och ta emot fakturor.
 * - Nyhetsbrev skickas till prenumeranter enligt schema och köhantering.
 * - Användare kan interagera med innehåll via reaktioner, kommentarer, bokmärken och läsa historik, vilket möjliggör personalisering.
 * - Systemet lagrar samtycken, hanterar integrationer (t.ex. väderdata), och loggar viktiga händelser för analys och regelefterlevnad.
 */
// ---------------------------
// Prisma Client + Datakälla
// ---------------------------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------
// ENUMS
// ---------------------------

enum RoleName {
  ADMIN
  EDITOR
  READER
}

enum ArticleStatus {
  DRAFT
  REVIEW
  SCHEDULED
  PUBLISHED
  ARCHIVED
}

enum ReactionKind {
  LIKE
  LOVE
  INSIGHTFUL
  SAD
  ANGRY
}

enum NewsletterCadence {
  DAILY
  WEEKLY
  CUSTOM
}

enum PaymentStatus {
  REQUIRES_ACTION
  SUCCEEDED
  FAILED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

enum RenewalMode {
  NONE
  MANUAL
  AUTO
}

// ---------------------------
// AUTH / USERS
// ---------------------------
// Bas: användare, roller, sessioner och e-postflöden

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  passwordHash    String
  status          String           @default("ACTIVE")
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations
  roles           UserRole[]
  sessions        Session[]
  emailTokens     EmailVerificationToken[]
  passwordResets  PasswordResetToken[]

  // Content & interaktion
  articles        Article[]        @relation("AuthorArticles")
  comments        Comment[]
  reactions       Reaction[]
  bookmarks       Bookmark[]
  readHistory     ReadHistory[]
  editedVersions  ArticleVersion[] @relation("EditedVersions")
  reportedComments CommentReport[] @relation("UserCommentReports")
  orders          Order[]          @relation("UserOrders")
  pageViews       PageView[]       @relation("UserPageViews")
  consents        ConsentEvent[]   @relation("UserConsents")

  // Betalning & prenumerationer
  subscriptions   Subscription[]
  invoices        Invoice[]
  paymentMethods  PaymentMethod[]
  payments        PaymentIntent[]  @relation("UserPayments")

  // Kommunikation
  newsletterSubs  NewsletterSubscription[]
  emailQueueItems EmailQueue[]     @relation("EmailQueueToUser")

  // Profil & preferenser
  profile         UserProfile?
  preference      UserPreference?

  // Loggar
  auditLogs       AuditLog[]       @relation("ActorAuditLogs")

  @@map("user")
}

model Role {
  id          String     @id @default(cuid())
  name        RoleName   @unique
  description String?

  users       UserRole[]

  @@map("role")
}

model UserRole {
  userId String
  roleId String
  user   User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  role   Role  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@map("user_role")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  meta      Json?

  @@map("session")
}

/// E-postverifiering och reset-tokens
model EmailVerificationToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  consumedAt DateTime?
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_verification_token")
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  expiresAt  DateTime
  consumedAt DateTime?
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_reset_token")
}

// ---------------------------
// USER EXTRAS (publik profil + inställningar)
// ---------------------------

model UserProfile {
  userId      String  @id
  displayName String
  authorSlug  String  @unique
  avatarUrl   String?
  bio         String?
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([authorSlug])

  @@map("user_profile")
}

model UserPreference {
  userId            String   @id
  locale            String   @default("sv-SE")
  timezone          String   @default("Europe/Stockholm")
  emailNotifications Boolean @default(true)
  pushNotifications  Boolean @default(false)
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preference")
}

// ---------------------------
// CONTENT
// ---------------------------
// Kategorier, taggar, media, artikel (med versionshistorik)

model Category {
  id        String    @id @default(cuid())
  slug      String    @unique
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  articles  Article[]

  @@index([deletedAt])
  @@map("category")
}

model Tag {
  id        String    @id @default(cuid())
  slug      String    @unique
  name      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  articles  ArticleTag[]

  @@index([deletedAt])
  @@map("tag")
}

model MediaAsset {
  id         String   @id @default(cuid())
  kind       String
  url        String
  width      Int?
  height     Int?
  alt        String?
  checksum   String?  @unique
  createdBy  String?
  createdAt  DateTime @default(now())
  deletedAt  DateTime?

  articles  Article[] @relation("ArticleImage")
  products  Product[] @relation("ProductImage")

  @@index([deletedAt])
  @@map("media_asset")
}

model Article {
  id             String        @id @default(cuid())
  slug           String
  language       String        @default("sv")
  headline       String
  summary        String?
  contentRich    Json
  imageId        String?
  image          MediaAsset?   @relation("ArticleImage", fields: [imageId], references: [id])
  categoryId     String
  category       Category      @relation(fields: [categoryId], references: [id])
  authorId       String
  author         User          @relation("AuthorArticles", fields: [authorId], references: [id])
  status         ArticleStatus @default(DRAFT)
  isEditorChoice Boolean       @default(false)
  scheduledAt    DateTime?
  publishedAt    DateTime?
  views          Int           @default(0)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  deletedAt      DateTime?

  versions       ArticleVersion[]
  tags           ArticleTag[]
  comments       Comment[]
  reactions      Reaction[]
  bookmarks      Bookmark[]
  reads          ReadHistory[]
  editorPick     EditorPickOrder? @relation("EditorPick")
  pageViews      PageView[]       @relation("ArticlePageViews")

  @@unique([slug, language])
  @@index([status, publishedAt(sort: Desc)])
  @@index([categoryId])
  @@index([authorId])
  @@index([deletedAt])
  @@index([scheduledAt])
  @@map("article")
}

model ArticleVersion {
  id         String   @id @default(cuid())
  articleId  String
  versionNo  Int
  diff       Json?
  snapshot   Json?
  editorId   String?
  note       String?
  createdAt  DateTime @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  editor     User?    @relation("EditedVersions", fields: [editorId], references: [id])

  @@unique([articleId, versionNo])
  @@map("article_version")
}

model ArticleTag {
  articleId String
  tagId     String
  article   Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([articleId, tagId])
  @@map("article_tag")
}

model Comment {
  id         String   @id @default(cuid())
  articleId  String
  userId     String
  body       String
  status     String   @default("VISIBLE")
  createdAt  DateTime @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports     CommentReport[] @relation("CommentReports")

  @@index([articleId, status])
  @@map("comment")
}

model Reaction {
  id         String       @id @default(cuid())
  articleId  String
  userId     String
  kind       ReactionKind
  createdAt  DateTime     @default(now())

  article    Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([articleId, userId, kind])
  @@map("reaction")
}

// Rapporter för moderation
model CommentReport {
  id         String   @id @default(cuid())
  commentId  String
  reporterId String?
  reason     String
  createdAt  DateTime @default(now())
  comment    Comment  @relation("CommentReports", fields: [commentId], references: [id], onDelete: Cascade)
  reporter   User?    @relation("UserCommentReports", fields: [reporterId], references: [id], onDelete: SetNull)
  @@index([commentId, createdAt])

  @@map("comment_report")
}

// Editor’s choice ordning per period
model EditorPickOrder {
  id        String   @id @default(cuid())
  articleId String   @unique
  rank      Int
  fromDate  DateTime
  toDate    DateTime?

  article   Article  @relation("EditorPick", fields: [articleId], references: [id], onDelete: Cascade)
  @@index([fromDate, toDate])

  @@map("editor_pick_order")
}

// ---------------------------
// COMMERCE (prenumeration + betalning + fakturor)
// ---------------------------

model SubscriptionType {
  id           String   @id @default(cuid())
  name         String   @unique
  description  String?
  priceSek     Decimal  @db.Decimal(10,2)
  durationDays Int
  features     Json?
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  subscriptions Subscription[]

  @@map("subscription_type")
}

model Subscription {
  id          String              @id @default(cuid())
  userId      String
  typeId      String
  startedAt   DateTime            @default(now())
  expiresAt   DateTime
  status      SubscriptionStatus  @default(ACTIVE)
  renewalMode RenewalMode         @default(NONE)

  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        SubscriptionType    @relation(fields: [typeId], references: [id])
  payments    PaymentIntent[]
  invoices    Invoice[]

  @@index([userId, status])
  @@map("subscription")
}

// Kundens sparade betalmetoder (Stripe m.m.)
model PaymentMethod {
  id           String   @id @default(cuid())
  userId       String
  provider     String
  customerRef  String
  methodRef    String
  isDefault    Boolean  @default(false)
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, methodRef])
  @@index([userId, isDefault])
  @@map("payment_method")
}

// Betalningsintentioner (kan kopplas till order eller prenumeration)
model PaymentIntent {
  id             String         @id @default(cuid())
  userId         String
  subscriptionId String?
  orderId        String?
  amountSek      Decimal        @db.Decimal(10,2)
  status         PaymentStatus
  provider       String
  providerRef    String?        @unique
  idempotencyKey String?        @unique
  createdAt      DateTime       @default(now())

  user           User           @relation("UserPayments", fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription?  @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  order          Order?         @relation(fields: [orderId], references: [id], onDelete: SetNull)

  @@map("payment_intent")
}

model Invoice {
  id             String    @id @default(cuid())
  userId         String
  subscriptionId String?
  amountSek      Decimal   @db.Decimal(10,2)
  vatSek         Decimal   @db.Decimal(10,2)
  issuedAt       DateTime  @default(now())
  paidAt         DateTime?
  pdfUrl         String?

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@map("invoice")
}

// (Valfri) enkel webshop för framtida behov
model Product {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  priceSek    Decimal  @db.Decimal(10,2)
  imageId     String?
  image       MediaAsset? @relation("ProductImage", fields: [imageId], references: [id])
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  orderItems  OrderItem[] @relation("ProductOrderItems")

  @@map("product")
}

model Order {
  id         String   @id @default(cuid())
  userId     String?
  totalSek   Decimal  @db.Decimal(10,2)
  status     String   @default("CREATED")
  createdAt  DateTime @default(now())
  paidAt     DateTime?

  user       User?    @relation("UserOrders", fields: [userId], references: [id], onDelete: SetNull)
  items      OrderItem[]
  payments   PaymentIntent[]

  @@map("order")
}

model OrderItem {
  orderId   String
  productId String
  qty       Int     @default(1)
  unitSek   Decimal @db.Decimal(10,2)

  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product   Product @relation("ProductOrderItems", fields: [productId], references: [id], onDelete: Restrict)

  @@id([orderId, productId])
  @@map("order_item")
}

// ---------------------------
// COMMS (nyhetsbrev + mailkö)
// ---------------------------

model Newsletter {
  id          String            @id @default(cuid())
  name        String            @unique
  description String?
  cadence     NewsletterCadence
  templateId  String?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  subscriptions NewsletterSubscription[]
  schedule      NewsletterSchedule?

  @@map("newsletter")
}

model NewsletterSubscription {
  id             String     @id @default(cuid())
  userId         String
  newsletterId   String
  preferences    Json?
  createdAt      DateTime   @default(now())
  unsubscribedAt DateTime?

  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  newsletter  Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)

  @@unique([userId, newsletterId])
  @@map("newsletter_subscription")
}

// Körschema per nyhetsbrev (DAILY/WEEKLY/CUSTOM)
model NewsletterSchedule {
  id           String     @id @default(cuid())
  newsletterId String     @unique
  dayOfWeek    Int?
  hourOfDay    Int?
  customSpec   String?
  newsletter   Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)

  @@map("newsletter_schedule")
}

// Outbox/Jobbkö för utskick och andra batchjobb
model OutboxJob {
  id         String   @id @default(cuid())
  kind       String
  payload    Json
  runAfter   DateTime @default(now())
  attempts   Int      @default(0)
  lastError  String?
  lockedAt   DateTime?
  doneAt     DateTime?

  @@index([kind, runAfter])
  @@map("outbox_job")
}

// E-postkö (transaktionella mail)
model EmailQueue {
  id          String    @id @default(cuid())
  toUserId    String
  subject     String
  bodyHtml    String
  templateId  String?
  scheduledAt DateTime?
  sentAt      DateTime?
  status      String     @default("QUEUED")
  error       String?

  toUser      User       @relation("EmailQueueToUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([status, scheduledAt])
  @@unique([toUserId, subject, scheduledAt])
  @@map("email_queue")
}

// ---------------------------
// PERSONALIZATION
// ---------------------------

model Bookmark {
  userId    String
  articleId String
  createdAt DateTime @default(now())

  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  article   Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@id([userId, articleId])
  @@map("bookmark")
}

model ReadHistory {
  id        String   @id @default(cuid())
  userId    String
  articleId String
  readAt    DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@map("read_history")
}

// ---------------------------
// INTEGRATIONS
// ---------------------------

model ExternalDataCache {
  id        String   @id @default(cuid())
  source    String
  cacheKey  String
  payload   Json
  fetchedAt DateTime @default(now())
  ttlSec    Int      @default(900)

  @@unique([source, cacheKey])
  @@map("external_data_cache")
}

model WebhookEvent {
  id          String   @id @default(cuid())
  provider    String
  eventType   String
  payload     Json
  receivedAt  DateTime @default(now())
  processedAt DateTime?
  status      String   @default("PENDING")
  @@index([provider, status])

  @@map("webhook_event")
}

// ---------------------------
// OPS & ANALYTICS
// ---------------------------

model PageView {
  id         String   @id @default(cuid())
  userId     String?
  sessionId  String?
  path       String
  articleId  String?
  occurredAt DateTime @default(now())
  uaHash     String?
  country    String?

  user       User?    @relation("UserPageViews", fields: [userId], references: [id], onDelete: SetNull)
  article    Article? @relation("ArticlePageViews", fields: [articleId], references: [id], onDelete: SetNull)

  @@index([occurredAt])
  @@index([articleId])
  @@map("page_view")
}

model AuditLog {
  id           String   @id @default(cuid())
  actorUserId  String?
  action       String
  entity       String
  entityId     String?
  metadata     Json?
  createdAt    DateTime @default(now())

  actor        User?    @relation("ActorAuditLogs", fields: [actorUserId], references: [id], onDelete: SetNull)
  @@index([entity, createdAt])

  @@map("audit_log")
}

// ---------------------------
// PRIVACY / COMPLIANCE
// ---------------------------

model ConsentEvent {
  id         String   @id @default(cuid())
  userId     String?
  kind       String
  version    String
  granted    Boolean
  ipHash     String?
  uaHash     String?
  occurredAt DateTime @default(now())

  user       User?    @relation("UserConsents", fields: [userId], references: [id], onDelete: SetNull)

  @@index([kind, occurredAt])
  @@map("consent_event")
}

// ---------------------------
// FTS (manuell patch efter migrering)
// ---------------------------
// Lägg tsvector-kolumner och triggers via SQL efter `prisma migrate` om ni vill ha Postgres FTS.